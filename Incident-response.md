# 장애 대응 사례 정리 
---

## 📌 사례 1 — 로그인 쿠키가 브라우저에 저장되지 않는 문제

### **1) 문제 상황**

* OAuth2 로그인은 성공했음에도, 브라우저에 인증 쿠키가 저장되지 않아 이후 API 요청에서 인증이 되지 않음.
* Set-Cookie 응답은 내려오지만, 브라우저 저장소에 쿠키가 보이지 않음.

### **2) 원인 분석**

* Chrome Network 탭에서 확인 결과, 쿠키는 정상적으로 내려오고 있음.
* 하지만 브라우저가 저장을 거부 → `SameSite` 정책 문제로 의심.
* 실제로 SameSite=Lax 기본값 + HTTPS 미적용 환경 조합에서 쿠키가 차단되는 패턴 확인.

### **3) 해결 방법**

* HTTPS 환경 구축 후 쿠키 옵션을 `SameSite=None`, `Secure`로 변경.
* 도메인 및 Path 설정 정확히 맞춰 재설정.

### **4) 재발 방지 조치**

* OAuth2 인증 플로우 체크리스트 문서화.
* 로컬 개발 환경도 HTTPS 기반으로 테스트 가능하도록 개선.
* 로그인/인증 관련 E2E 테스트 추가.

---

## 📌 사례 2 — JPA LazyInitializationException 발생

### **1) 문제 상황**

* 특정 엔드포인트 호출 시, JSON 변환 과정에서 Lazy 필드가 초기화되지 않아 500 에러 발생.

### **2) 원인 분석**

* 서비스 계층이 아닌 컨트롤러 또는 JSON 변환 과정에서 Lazy 필드 접근.
* 트랜잭션 범위 밖에서 Proxy 객체 접근이 일어남.

### **3) 해결 방법**

* Lazy 필드를 직접 반환하지 않고, **서비스 계층에서 DTO로 변환**하도록 구조 변경.
* 필요한 연관관계는 **fetch join**으로 미리 로딩.
* BatchSize 설정으로 N+1도 함께 완화.

### **4) 재발 방지 조치**

* "Entity를 API로 직접 반환 금지" 원칙 문서화.
* DTO 변환 규칙 강화.
* 연관관계 설계 및 Fetch 전략 점검 체크리스트 작성.

---

## 📌 사례 3 — Nginx 502 Bad Gateway 발생

### **1) 문제 상황**

* 배포 후 도메인 접속 시 `502 Bad Gateway` 화면 표시.
* 백엔드 서버는 정상적으로 실행 중.

### **2) 원인 분석**

* Nginx `upstream` 설정 확인 결과, 컨테이너 포트를 잘못 지정(8080 → 8082).
* healthcheck는 통과하지만 실제 서비스 포트 mismatch.

### **3) 해결 방법**

* `proxy_pass` 및 upstream 포트 수정.
* Nginx reload 후 정상 작동 확인.

### **4) 재발 방지 조치**

* 배포 체크리스트에 Nginx upstream 포트 검증 항목 추가.
* docker-compose 포트 매핑을 README에 명확히 문서화.

---

## 📌 사례 4 — 자동검색 API 성능 저하 (1,200ms → 60ms)

### **1) 문제 상황**

* 자동완성 검색어 입력 시 응답 시간이 1초 이상 걸리며 UX 매우 저하.
* CPU 사용량 증가, DB 부하 급증.

### **2) 원인 분석**

* 쿼리: `WHERE name LIKE '%keyword%'` → **전체 테이블 스캔 발생**.
* 인덱스 부재 + 조인 비용 증가.

### **3) 해결 방법**

* `pg_trgm` 확장 + GIN 인덱스 적용.
* prefix 검색은 Redis 캐시로 처리하며 속도 향상.
* API에 debounce 적용하여 요청량 자체도 감소.

### **4) 재발 방지 조치**

* Slow Query 로그 활성화.
* 검색어 패턴 분석 및 캐시 구조 개선.
* 주기적 인덱스 모니터링.

---



## 📌 사례 5 — 파일전송시에 오류 발생(사이즈)

### **1) 문제 상황**

* 팀프로젝트 중의 게시판 기능을 개발하는 도중에 프론트 팀원으로 부터 오류 발생확인
* 게시물 작성,수정중에 첨부파일 첨부시 오류
### **2) 원인 분석**

* 서버 로그 확인 후
 ```
org.apache.tomcat.util.http.fileupload.impl.FileSizeLimitExceededException: The field files exceeds its maximum permitted size of 1048576 bytes.
 ```
해당 에러 확인, 첨부파일이 톰캣에서 허용하는 최대치에 다다른 것으로 판단

### **3) 해결 방법**

* spring.servlet.multipart.max-file-size=20MB
* spring.servlet.multipart.max-request-size=20MB
으로 수정하였고 정상적으로 파일 수정도 가능

### **4) 재발 방지 조치**

* 스프링을 통해 파일을 처리할때는 서버에서 받아드리는 파일의 기본값이 존재한다는 것을 인지하였고 이 문서에 오류 목록을 확인하여 다른 프로젝트에서도 초기 세팅시에 활용
